---
title: Create waterfall chart with GGPLOT2
author: Anh Hoang Duc
date: '2018-05-09'
slug: create-waterfall-chart-with-ggplot2
categories:
  - R
  - Vizualization
tags: 
  - Vizualization
summary: "Create beautifual waterfall chart with GGPLOT2"
output: 
  html_document: 
    df_print: kable
---

```{r setup, include = F}
knitr::opts_chunk$set(warning = F, message = F)
```


In digital world, active users is very important metrics but is quite hard to descrile performance of a website/service overtime. Typically, the formula of active user at given time *t* can be describle as follows:

$$active_{t} = active_{t-1} = new_{t} - churn_{t}$$

Naturally, waterfall chart comes to my mind as an candidate to vizualize performance of active users overtime. So, I tried to look for some real case study using waterfall chart for this very problem using R but I was stuck. However, after coules of hours looking through various sources, I found a really impressive use case of using Tableau to vizualize subscribe churn activity as follows.

![](/img/20180509-subscribe-activity.png)

The original link to the above chart can be found [here](https://public.tableau.com/views/CH24_BBOD_ChurnTurnover/SubscriberChurnAnalysis)

So, the next task of mine was to make similar chart with GGPLOT2 that I would like to share with R users,

```{r}
# Load library
library(tidyverse)
library(ggplot2)
library(reshape2)
library(lubridate)
library(grid)
library(gridExtra)

# Create data for simulation
set.seed(123)
data <- data.frame(date = seq(1, 372, by = 31) %>% as_date)
data <- data %>% 
  mutate(new = abs(rnorm(12, 100, 10)) %>% round(0)) %>% 
  mutate(churn = abs(rnorm(12, 50, 30)) %>% round(0)) %>% 
  mutate(net = new - churn)  %>% 
  mutate(eop = cumsum(net)) %>% 
  select(-net)

data
```

As you can see, data was generated randomly such that eop (end of period) user equal to end of privious period plus new users in current period minus churn users. It is very typical data for active/churn problems.

To create waterfall chart, we could use `geom_segment` from ggplot2 

```{r}
# Define the width of segment
step <- 0.4*(max(data$date) - min(data$date))/(nrow(data) - 1)

# Define ymax of segment
data <- data %>% 
  mutate(ymax = eop + churn)

# Define ymin of segment
df <- data %>% 
  melt(id.vars = c("date", "eop", "ymax")) %>% 
  mutate(ymin = ymax - value) %>% 
  rename(group = variable)

# Define xmin and xmax of segments
df <- df %>% 
  mutate(xmin = case_when(
    group == "new" ~ date - step,
    TRUE ~ date 
  )) %>% 
  mutate(xmax = case_when(
    group == "new" ~ date,
    TRUE ~ date + step
  ))


# Create waterfall chart
df %>% 
  arrange(date) %>% 
  ggplot() +
  geom_rect(aes(xmin = xmin,
                xmax = xmax,
                ymin = ymin,
                ymax = ymax,
                fill = group)) -> p1
p1
```

We have successfully created a waterfall chart! So, the next steps are to optimize colors & create the line chart.

```{r}
# Create data for line chart
df2 <- df %>% select(date, eop) %>% distinct()

# Optimize colors, themes & add lines
p2 <- p1  + 
  geom_line(aes(date, eop), col = "dodgerblue4", size = 1) +
  geom_point(aes(date, eop), col = "dodgerblue4", size = 2.5) +
  geom_text(aes(date, eop, label = eop), vjust = 1.2, 
            hjust = -0.1) +
  scale_fill_manual(values = c("grey60", "coral2")) +
  theme_minimal() +
  theme(
    axis.line = element_line(color = "gray40", size = 0.5),
    legend.position = "top") +
  scale_x_date(breaks = data$date,
               date_labels = "%b") +
  theme(panel.grid.minor.x = element_blank(),
        legend.title = element_blank()) +
  ggtitle("Overview of active users") +
  xlab("Date") + 
  ylab("Number of active users")
p2
```

Not bad, right! The next chart will be the classic bar chart with `geom_bar`.

```{r}
p3 <- df %>% 
  mutate(value = case_when(
    group == "churn" ~ -1 * value,
    TRUE ~ value
  )) %>% 
  ggplot(aes(date, value)) +
  geom_bar(aes(fill = group), stat = "identity") +
  scale_fill_manual(values = c("grey60", "coral2")) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank(),
    axis.text.x = element_text(angle = 90)
  ) +
  scale_x_date(breaks = data$date,
               date_labels = "%b") 
p3
```

And, the final step is to combine the two above charts together using `grid` & `gridExtra` packages!

```{r}
grid.newpage()

# Define position of the main chart
position_1 <- viewport(width = 1, height = 1, x = 0.5, y = 0.5)  # the larger map

# Position of the secondary chart
position_2 <- viewport(width = 0.35, height = 0.25, x = 0.25, y = 0.75)  

print(p2, vp = position_1)
print(p3, vp = position_2)
```

Done! We have created a very beautiful waterfall chart using `ggplot2`! 

