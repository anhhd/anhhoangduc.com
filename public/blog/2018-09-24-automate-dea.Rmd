---
title: Automating Data Exploratory Analysis with purrr and NSE
author: Anh Hoang Duc
date: '2018-08-25'
slug: automate-dea-with-purrr-and-NSE
categories:
  - programming
tags: [programming]
summary: "Using purrr with NSE to automate data exploratory analysis"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      warning = F, 
                      message = F, 
                      fig.height = 5)
```

In the life of an analyst, one have to spend much time on data exploratory analysis. When you have to repeat the task multiple times, you might need to write a function. For example, I often need to do an analysis between a numeric variable and a factor variable in the following process:

- Compare statistics among groups (`mean`, `median`,...)
- Make an ANOVA model to compare `mean` among groups
- Draw some chart to vizualize difference among groups

To solve this problem, I create a function called `compare_group` as follows:

```{r}
library(tidyverse)
library(patchwork)
compare_group <- function(data,
                         value,
                         group){
  value <- enquo(value)
  group <- enquo(group)
  value_name <- quo_name(value)
  group_name <- quo_name(group)
  
  cat(paste0("Compare ", value_name, " with ", group_name))
  cat("\n----------------------------------------\n")
  #Compare two variable
  df <- data %>% select(!!value, !!group)
  df %>% 
    group_by(!!group) %>% 
    summarise_at(vars(!!value),
                 funs(n(), mean, median, 
                      min,
                      q25 = quantile(., 0.25),
                      q75 = quantile(.,0.75),
                      p90 = quantile(., 0.9),
                      q95 = quantile(., .95),
                      max)) %>% print

  formula.aov <- paste(value_name, group_name, sep = "~")
  
  cat("\n----------------------------------------")
  cat(paste0("\n# Anova analysis: ", formula.aov))
  cat("\n----------------------------------------\n\n")

  aov(formula(formula.aov), data = df) %>% TukeyHSD() %>% print;
  
  p1 <- ggplot(data, aes(!!group, !!value, fill = !!group)) +
    geom_boxplot(aes(fill = !!group)) + 
    scale_y_log10() +
    labs(title = paste0(value_name, " by ", group_name)) +
    theme_minimal() +
    theme(legend.position = "none");
#  p1 %>% print();
  
  p2 <- ggplot(data, aes(!!value)) +
    geom_density(aes(fill = !!group), alpha = 0.7) + 
    labs(title = paste0("Density of ", value_name)) +
    theme_minimal() +
    theme(legend.position = "top");
#  p2 %>% print();
  print(p1+p2)
}
```

Let's have a quick test.

```{r}
iris %>% compare_group(Sepal.Length, Species)
```

The above solution has saved me hours and release my time to focus on reading and making sense of result. However, if you want to analyze multiple numeric variables with one category variable, the traditional approches are somewhat cubersome. 

**Ilustrative example**: For all numeric variables in dataset iris, make an analysis to analysis this variable with `Species`.

```{r, warning = F, message = F}
library(tidyverse)
iris %>% head
```

The traditinal ways to do the task are to follow 2 approaches:

- Make analysis for every variables without loop. For example: `compare_group(Sepal.Length, Species)` and repeat it for each & every variable.
- Make a `for loop` to run a loop for analysis. However, this approach has some limitation, especially in readability in coding & diffculty in programming.

To overcome this diffculty, you can use `map` in `purrr` and modify some part of `compare_group` function. The strategy is as follows.

- Step 1: Modify the `compare_group` function to fix data and group variable for analysis
- Step 2: Map all numeric variables to the new function.

Let see the example below.

# Step 1: Modify function

```{r}
# Step 1: Create the function

my_stat <- function(x){
  x <- enquo(x)
  iris %>% 
    compare_group(!!x, Species)
}

# Test the function
my_stat(Sepal.Length)
```

# Step 2: Using map to automate analysis

```{r}
# Step 2: Apply map for the new function

library(purrr)
iris %>% 
  select_if(is.numeric) %>% 
  names %>% 
  syms %>% 
  map(my_stat)
```

The trick here is to use `syms` to combine the power of nonstandard evaluation and `map` in `purrr`. The power of functional programming & non-standard evaluation in `tidyverse` is incredible. This approach could help one release much time of programming and focus and results & insights.

